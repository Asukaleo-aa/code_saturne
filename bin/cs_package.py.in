#!/usr/bin/env python
# Package information, generated from cs_package.py.in by make.
#============================================================================
#
#     This file is part of the Code_Saturne Kernel, element of the
#     Code_Saturne CFD tool.
#
#     Copyright (C) 2010-2011 EDF S.A., France
#
#     contact: saturne-support@edf.fr
#
#     The Code_Saturne Kernel is free software; you can redistribute it
#     and/or modify it under the terms of the GNU General Public License
#     as published by the Free Software Foundation; either version 2 of
#     the License, or (at your option) any later version.
#
#     The Code_Saturne Kernel is distributed in the hope that it will be
#     of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with the Code_Saturne Kernel; if not, write to the
#     Free Software Foundation, Inc.,
#     51 Franklin St, Fifth Floor,
#     Boston, MA  02110-1301  USA
#
#============================================================================

#-------------------------------------------------------------------------------

import os
import sys

# Package information
#--------------------

class package:

    def __init__(self, scriptdir = None):

        self.name = "@PACKAGE_NAME@"
        self.tarname = "@PACKAGE_TARNAME@"
        self.version = "@PACKAGE_VERSION@"
        self.string = "@PACKAGE_STRING@"
        self.bugreport = "@PACKAGE_BUGREPORT@"
        self.url = "@PACKAGE_URL@"

        self.code_name = "Code_Saturne"

        self.preprocessor = "cs_preprocess"
        self.solver = "cs_solver"
        self.check_syntax = "cs_check_syntax"
        self.io_dump = "cs_io_dump"
        self.guiname = "SaturneGUI"
        self.configfile = "code_saturne.cfg"
        self.scratchdir = 'tmp_Saturne'
        self.srcdir = 'src_saturne'

        # Compilers, flags and special commands

        # PLE library can be an internal or external library
        # Its flags are included in other build flags,
        # but are made available here for "code_saturne config".

        self.compilers = {'cc': "@CC@",
                          'cxx': "@CXX@",
                          'fc': "@FC@",
                          'ld': "@CS_LD@"}

        self.flags = {'cppflags': "-DHAVE_CONFIG_H @CS_CPPFLAGS@",
                      'cflags': "@CS_CFLAGS@",
                      'cxxflags': "@CS_CXXFLAGS@",
                      'fcflags': "@CS_FCFLAGS@",
                      'fcmoddir': "@pkgincludedir@",
                      'ldflags': "@CS_LDFLAGS@",
                      'libs': "-lsaturne @CS_LIBS@",
                      'deplibs': "@LDFLAGS@ @LIBINTL@ @LIBS@ @FCLIBS@",
                      'ple_cppflags': "@PLE_CPPFLAGS@",
                      'ple_ldflags': "@PLE_LDFLAGS@",
                      'ple_libs': "@PLE_LIBS@"}

        self.fcmodinclude = "@FCMODINCLUDE@"
        self.rpath = "@LDRPATH@"
        self.special_user_link = "@cs_special_user_link@"

        # Installation directories

        self.scriptdir = scriptdir

        self.dirs = {'prefix': ("", "@prefix@"),
                     'exec_prefix': ("", "@exec_prefix@"),
                     'bindir': ("bin", "@bindir@"),
                     'includedir': ("incude", "@includedir@"),
                     'pkgincludedir': (os.path.join("include", self.name),
                                       "@pkgincludedir@"),
                     'libdir': ("lib", "@libdir@"),
                     'libexecdir': ("libexec", "@libexecdir@"),
                     'pkglibexecdir': (os.path.join("libexec", self.name),
                                       "@pkglibexecdir@"),
                     'pythondir': (os.path.join("lib",
                                                "python" + sys.version[:3],
                                                "site-packages"),
                                   "@pythondir@"),
                     'pkgpythondir': (os.path.join("lib",
                                                   "python" + sys.version[:3],
                                                   "site-packages",
                                                   self.name),
                                      "@pkgpythondir@"),
                     'localedir': (os.path.join("share", "locale"),
                                   "@localedir@"),
                     'datarootdir': ("share", "@datarootdir@"),
                     'datadir': ("share", "@datadir@"),
                     'pkgdatadir': (os.path.join("share", self.name),
                                    "@pkgdatadir@"),
                     'docdir': (os.path.join("share", "doc", self.name),
                                "@docdir@"),
                     'pdfdir': (os.path.join("share", "doc", self.name),
                                "@pdfdir@"),
                     'sysconfdir': ("etc", "@sysconfdir@")}

        # Execution environment

        self.mpi_type = "@mpi_type@"
        self.mpi_bindir = "@mpi_bindir@"
        self.mpi_libdir = "@mpi_libdir@"

        self.env_modules = "@cs_env_modules@"
        self.env_modulecmd = "@MODULECMD@"

    def get_dir(self, installdir):

        import cs_config
        cfg = cs_config.config()

        # First, handle the standard "non relocatable" case
        if cfg.features['relocatable'] == "no":
            return self.dirs[installdir][1]

        # On Windows, executables are installed in "bindir" for DLL search
        if sys.platform.startswith("win") and \
                installdir in ("libexecdir", "pkglibexecdir"):
            installdir = "bindir"

        bindir = os.path.dirname(self.scriptdir)
        prefix = os.path.dirname(bindir)
        return os.path.join(prefix, self.dirs[installdir][0])

    def get_compiler(self, compiler):

        import cs_config
        cfg = cs_config.config()

        # First, handle the standard "non relocatable" case
        if cfg.features['relocatable'] == "no":
            return self.compilers[compiler]

        # On Windows, compilers are installed in "bindir" for DLL search
        if sys.platform.startswith("win"):
            bindir = os.path.dirname(self.scriptdir)
            return os.path.join(bindir, self.compilers[compiler])

        # On Linux systems, one assumes compilers are installed in the system
        else:
            return self.compilers[compiler]

    def get_flags(self, flag):

        import cs_config
        cfg = cs_config.config()

        # First, handle the standard "non relocatable" case
        if cfg.features['relocatable'] == "no":
            return self.flags[flag]

        # On Windows, flags must be adapted so as to handle the relocation
        # of system headers (together with the compiler)
        if sys.platform.startswith("win"):
            tmp_flags = self.flags[flag]
            for p in ["-I/mingw", "-Ic:/mingw"]:
                tmp_flags = tmp_flags.replace(p, "-I" + self.get_dir("prefix"))
            for p in ["-L/mingw", "-Lc:/mingw"]:
                tmp_flags = tmp_flags.replace(p, "-L" + self.get_dir("prefix"))

        # Now, handle special cases for relocatable installation
        if flag == "cppflags":
            tmp_flags = "-I" + self.get_dir("pkgincludedir") + " " + tmp_flags
        elif flag == "ple_cppflags":
            tmp_flags = "-I" + self.get_dir("includedir") + " " + tmp_flags
        elif flag == "fcmoddir":
            tmp_flags = self.get_dir("pkgincludedir")
        elif flag == "ple_ldflags":
            tmp_flags = "-L" + self.get_dir("libdir") + " " + tmp_flags

        return tmp_flags

    def get_preprocessor(self):

        return os.path.join(self.get_dir("pkglibexecdir"),
                            self.preprocessor)

    def get_io_dump(self):

        return os.path.join(self.get_dir("pkglibexecdir"),
                            self.io_dump)

    def get_solver(self):

        return os.path.join(self.get_dir("pkglibexecdir"),
                            self.solver)

    def get_check_syntax(self):

        return os.path.join(self.get_dir("pkglibexecdir"),
                            self.check_syntax)

    def get_io_dump(self):

        return os.path.join(self.get_dir("pkglibexecdir"),
                            self.io_dump)

    def get_configfile(self):

        return os.path.join(self.get_dir("sysconfdir"),
                            self.configfile)

    def get_batchdir(self):

        return os.path.join(self.get_dir("pkgdatadir"),
                            'batch')

    def get_runcase_script(self, script):

        return os.path.join(self.get_dir("pkgdatadir"),
                            script)

    def get_alternate_version(self, version):
        """
        Return alternate version package object
        """

        pkg = None

        # Determine path (by absolute or local name)
        pythondir = os.path.normpath(version)
        prefix = os.path.normpath(self.get_dir("exec_prefix"))
        if self.get_dir("pkgpythondir").find(prefix) > -1:
            postfix = self.get_dir("pkgpythondir")[len(prefix)+1:]
            if not os.path.isabs(pythondir):
                prefix = os.path.split(prefix)[0]
            else:
                prefix = version
            pythondir = os.path.normpath(os.path.join(prefix,
                                                      version,
                                                      postfix))

        # load alternate package
        if os.path.isdir(pythondir):
            import sys
            sys.path.insert(0, pythondir)
            import cs_package
            reload(cs_package)
            pkg = cs_package.package()
            sys.path.pop(0)
        else:
            raise ImportError("Alternative version '" + pythondir + "' not found.")

        return pkg

#-------------------------------------------------------------------------------
